import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { PATHS } from './config.js';
import { compareWithExisting } from './validator.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export async function updateUnitsJson(scrapedData) {
  try {
    // Read the existing units.json file
    const unitsJsonPath = path.resolve(__dirname, '../../', PATHS.unitsJson);
    const existingContent = await fs.readFile(unitsJsonPath, 'utf-8');
    const existingData = JSON.parse(existingContent);
    
    // Compare scraped data with existing data
    const comparison = compareWithExisting(scrapedData, existingData);
    
    if (!comparison.hasChanges) {
      return {
        hasChanges: false,
        updatedUnits: 0,
        changes: comparison.changes
      };
    }
    
    // Create updated units array
    const updatedUnits = existingData.units.map(unit => {
      const scrapedUnit = scrapedData[unit.id];
      
      if (scrapedUnit) {
        // Update counters while preserving other unit data
        return {
          ...unit,
          counters: {
            effectiveAgainst: scrapedUnit.effectiveAgainst,
            counteredBy: scrapedUnit.counteredBy
          }
        };
      }
      
      return unit;
    });
    
    // Add any new units (if they exist in scraped data but not in existing)
    comparison.changes.added.forEach(unitId => {
      const scrapedUnit = scrapedData[unitId];
      if (scrapedUnit) {
        // Note: We'd need additional unit information (name, image, cost) 
        // This would require enhancing the scraper or maintaining a separate mapping
        console.warn(`New unit found with ID ${unitId}, but missing metadata. Skipping.`);
      }
    });
    
    // Create the updated data structure
    const updatedData = {
      units: updatedUnits
    };
    
    // Write the updated data back to units.json
    await fs.writeFile(
      unitsJsonPath,
      JSON.stringify(updatedData, null, 2),
      'utf-8'
    );
    
    // Generate a detailed change report
    const changeReport = generateChangeReport(comparison.changes);
    
    return {
      hasChanges: true,
      updatedUnits: comparison.changes.modified.length,
      changes: comparison.changes,
      report: changeReport
    };
    
  } catch (error) {
    console.error('Error updating units.json:', error);
    throw new Error(`Failed to update units.json: ${error.message}`);
  }
}

function generateChangeReport(changes) {
  const lines = [];
  
  lines.push('=== Counter Data Update Report ===');
  lines.push(`Date: ${new Date().toISOString()}`);
  lines.push('');
  
  if (changes.added.length > 0) {
    lines.push(`Added Units (${changes.added.length}):`);
    changes.added.forEach(id => {
      lines.push(`  - Unit ID: ${id}`);
    });
    lines.push('');
  }
  
  if (changes.removed.length > 0) {
    lines.push(`Removed Units (${changes.removed.length}):`);
    changes.removed.forEach(id => {
      lines.push(`  - Unit ID: ${id}`);
    });
    lines.push('');
  }
  
  if (changes.modified.length > 0) {
    lines.push(`Modified Units (${changes.modified.length}):`);
    
    changes.modified.forEach(mod => {
      lines.push(`  ${mod.name} (ID: ${mod.id}):`);
      
      if (mod.changes.effectiveAgainst) {
        lines.push('    Effective Against:');
        lines.push(`      - Old: [${mod.changes.effectiveAgainst.old.join(', ')}]`);
        lines.push(`      - New: [${mod.changes.effectiveAgainst.new.join(', ')}]`);
      }
      
      if (mod.changes.counteredBy) {
        lines.push('    Countered By:');
        lines.push(`      - Old: [${mod.changes.counteredBy.old.join(', ')}]`);
        lines.push(`      - New: [${mod.changes.counteredBy.new.join(', ')}]`);
      }
      
      lines.push('');
    });
  }
  
  if (changes.added.length === 0 && changes.removed.length === 0 && changes.modified.length === 0) {
    lines.push('No changes detected.');
  }
  
  return lines.join('\n');
}

export async function createPullRequestBody(changes, report) {
  const body = `## Automated Counter Data Update

This pull request contains automated updates to the unit counter data scraped from mechamonarch.com.

### Summary of Changes
- **Modified Units**: ${changes.modified.length}
- **Added Units**: ${changes.added.length}
- **Removed Units**: ${changes.removed.length}

### Detailed Changes
\`\`\`
${report}
\`\`\`

### Source
Data sourced from: https://mechamonarch.com/guide/mechabellum-counters/
Scraped on: ${new Date().toISOString()}

---
*This PR was automatically generated by the Mechabellum counter data scraper.*
`;
  
  return body;
}